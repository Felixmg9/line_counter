При проверке тестового задания исходные коды были собраны на Ubuntu 22.04 с помощью компилятора g++ 11.3.0 из стандартного репозитория APT.

Если программе подать путь к директории с директориями, получаем следующую ошибку (такого быть не должно):

 

terminate called after throwing an instance of 'std::__ios_failure'  what():  basic_filebuf::underflow error reading the file: Is a directory
Aborted (core dumped)
 
В строке 49 можно было использовать константную ссылку при итерировании по directory_iterator, что и предлагает сделать компилятор при включении предупреждений.

Без аргументов программа выдает ошибку и пример использования (это хорошо).

Для ошибочного кода возврата предлагается использовать EXIT_SUCCESS/EXIT_FAILURE, определенные в cstdlib.

Использование глобальных переменных не приветствуется, особенно в случаях, когда их можно определить локально.

Использование знаковых типов int вместо unsigned int в случаях, где значения не должны быть отрицательными, чревато ошибками при переполнении типа.

Для уменьшения возможности переполнения предлагается использовать uintmax_t или uint64_t, если необходимо точно знать его размер. Типы определены в стандартной библиотеке cstdint.

У вас в коде возможен эффект гонок, поскольку доступ к глобальному счетчику ссылок не защищен от конкурентного доступа (плохо), поэтому разные запуски на одних и тех же входных данных могут давать разные результаты. Рекомендуется плотно проработать тему многопоточности и примитивов синхронизации.

Вместо явного выделения памяти через new с последующим созданием unique_ptr можно было использовать std::make_unique, который внутри сделает это лучше явных вызовов.

Непонятно, зачем было использовать std::basic_ifstream<char> вместо std::ifstream в new, хотя при создании умного указателя вы явно использовали последний вариант.

Непонятно, зачем было использовать динамическую память для доступа к файлу.

Использование вложенного цикла в строке 31 избыточно и при использовании с нестандартными реализациями (например, с классами-наследниками), может привести к undefined behavior, если в случае pos == size() будет возвращен ваш delim.

В случае, если у вас в файле вообще не будет разделителей строки, но будет текст, ваша программа вернет 0, что в некоторых случаях может быть некорректно.

Чтение всего файла в ОЗУ может быть проблемой, поскольку размера ОЗУ и файла подкачки может не хватить на чтение даже одного файла целиком.

Если у вас в директории будет много файлов, то одновременное создание потока на каждый файл может привести к неэффективной работе планировщика задач ОС и излишнему потреблению памяти процессом. Рекомендуется использовать ограничение, связанное с количеством доступных ядер на процессоре, например std::thread::hardware_concurrency из thread.

Не рекомендуется выносить описание глобальных переменных в заголовочный файл, а только объявления с ключевым словом extern, поскольку при подключении файла в различные блоки трансляции могут возникнуть ошибки связывания.

Заголовочный файлы рекомендуется защищать от повторного подключения через директивы препроцессора, например, через #pragma once.

При выводе строки рекомендуется также выводить std::endl в конце для более красивого отображения вывода, а также принудительного отображения данных.

В общем, программа выполняет свою работу, но не были обработаны некоторые краевые случаи. А также упущены потенциальные проблемы.

P.S. Если для запуска есть какие-то специальные требования, то их стоит указывать.
